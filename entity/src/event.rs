//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.3

use sea_orm::entity::prelude::*;
use sea_orm::{ColIdx, TryGetable, TryGetError};
use sea_orm::sea_query::{ArrayType, ValueType, ValueTypeErr};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq)]
#[sea_orm(table_name = "event")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub name: String,
    pub link: String,
    pub max_adults: i32,
    pub max_children: i32,
    pub max_adults_per_reservation: i32,
    pub max_children_per_reservation: i32,
    pub ts: DateTime,
    pub remind: DateTime,
    pub state: EventState,
    pub adult_ticket_price: i32,
    pub child_ticket_price: i32,
    pub currency: String,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::attachment::Entity")]
    Attachment,
    #[sea_orm(has_many = "super::current_events::Entity")]
    CurrentEvents,
    #[sea_orm(has_many = "super::message::Entity")]
    Message,
    #[sea_orm(has_many = "super::presence::Entity")]
    Presence,
    #[sea_orm(has_many = "super::reservation::Entity")]
    Reservation,
}

impl Related<super::attachment::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Attachment.def()
    }
}

impl Related<super::current_events::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::CurrentEvents.def()
    }
}

impl Related<super::message::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Message.def()
    }
}

impl Related<super::presence::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Presence.def()
    }
}

impl Related<super::reservation::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Reservation.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum EventState {
    Open,
    Close,
}

impl Default for EventState {
    fn default() -> Self {
        EventState::Open
    }
}

impl TryFrom<i32> for EventState {
    type Error = ();

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(EventState::Open),
            1 => Ok(EventState::Close),
            _ => Err(())
        }
    }
}

impl From<EventState> for i32 {
    fn from(value: EventState) -> Self {
        match value {
            EventState::Open => 0,
            EventState::Close => 1,
        }
    }
}

impl From<EventState> for Value {
    fn from(value: EventState) -> Self {
        Value::Int(Some(value.into()))
    }
}

impl TryGetable for EventState {
    fn try_get_by<I: ColIdx>(res: &QueryResult, index: I) -> Result<Self, TryGetError> {
        let state: Option<i32> = res.try_get_by(index).map_err(TryGetError::DbErr)?;

        if let Some(state) = state {
            if state == 0 {
                return Ok(EventState::Open);
            }
        }

        Ok(EventState::Close)
    }
}

impl ValueType for EventState {
    fn try_from(v: Value) -> Result<Self, ValueTypeErr> {
        match v {
            Value::Int(Some(val)) => {
                // avoid trait name collision https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name
                return TryFrom::try_from(val).map_err(|_| ValueTypeErr);
            }
            _ => Err(ValueTypeErr)
        }
    }

    fn type_name() -> String {
        stringify!(EventState).to_owned()
    }

    fn array_type() -> ArrayType {
        ArrayType::Int
    }

    fn column_type() -> ColumnType {
        ColumnType::Integer
    }
}
